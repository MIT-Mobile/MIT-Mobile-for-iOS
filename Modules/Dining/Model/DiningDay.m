#import "DiningDay.h"
#import "HouseVenue.h"
#import "DiningMeal.h"
#import "CoreDataManager.h"
#import "Foundation+MITAdditions.h"

@implementation DiningDay

@dynamic date;
@dynamic message;
@dynamic meals;
@dynamic houseVenue;

+ (DiningDay *)newDayWithDictionary:(NSDictionary *)dict {
    DiningDay *day = [CoreDataManager insertNewObjectForEntityForName:@"DiningDay"];
    
    NSDateFormatter *formatter = [[NSDateFormatter alloc] init];
    [formatter setDateFormat:@"yyyy-MM-dd"];
    [formatter setTimeZone:[NSTimeZone timeZoneWithName:@"America/New_York"]];
    NSDate *date = [formatter dateFromString:dict[@"date"]];
    day.date = date;
    
    if (dict[@"message"]) {
        day.message = dict[@"message"];
    }
    
    for (NSDictionary *mealDict in dict[@"meals"]) {
        DiningMeal *meal = [DiningMeal newMealWithDictionary:mealDict];
        [day addMealsObject:meal];
        
        // adjust all of the start and end times to be complete dates and times to make querying easier
        
        if (meal.startTime && meal.endTime) {
            NSDate *dayDate = day.date;

            meal.startTime = [dayDate dateWithTimeOfDayFromDate:meal.startTime];

            meal.endTime = [dayDate dateWithTimeOfDayFromDate:meal.endTime];
        }
    }
    
    NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"startTime" ascending:YES];
    NSArray *sortedMeals = [[day.meals array] sortedArrayUsingDescriptors:@[sort]];
    [day setMeals:[NSOrderedSet orderedSetWithArray:sortedMeals]];
    
    return day;
}

+ (DiningDay *)dayForDate:(NSDate *) date forVenue:(HouseVenue *)venue
{
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"date == %@ && houseVenue == %@", date, venue];
    NSArray * array = [CoreDataManager objectsForEntity:@"DiningDay" matchingPredicate:predicate];
    
    return [array lastObject];
}

+ (NSArray *)daysInWeekOfDate:(NSDate *)date forVenue:(HouseVenue *)venue
{
    // returns array of DiningDays with weekday component 1 thru 7 of date
    //      sorted ascending by date
    NSDateComponents *comps = [[NSCalendar currentCalendar] components:NSWeekdayCalendarUnit fromDate:date];
    NSTimeInterval secondsInDay = 60*60*24;
    NSDate *weekStart = [NSDate dateWithTimeInterval:-((comps.weekday - 1) * secondsInDay) sinceDate:date];         // -1 so index starts at 0. Sunday shifted from weekday 1 to weekday 0, allows for cleaner math
    NSDate *weekEnd = [NSDate dateWithTimeInterval:((7 - (comps.weekday - 1)) * secondsInDay) sinceDate:date];
    
    NSPredicate *pred = [NSPredicate predicateWithFormat:@"houseVenue == %@ AND date >= %@ AND date <= %@", venue, [weekStart startOfDay], [weekEnd endOfDay]];
    NSSortDescriptor *sort = [NSSortDescriptor sortDescriptorWithKey:@"date" ascending:YES];
    
    return [CoreDataManager objectsForEntity:@"DiningDay" matchingPredicate:pred sortDescriptors:@[sort]];
}

// There appears to be a bug in Apple's autogenerated NSOrderedSet accessors: http://stackoverflow.com/questions/7385439/exception-thrown-in-nsorderedset-generated-accessors
- (void)addMealsObject:(DiningMeal *)value {
    NSMutableOrderedSet* tempSet = [NSMutableOrderedSet orderedSetWithOrderedSet:self.meals];
    [tempSet addObject:value];
    self.meals = tempSet;
}

- (NSString *)allHoursSummary {
    NSMutableArray *summaries = [NSMutableArray array];
    for (DiningMeal *meal in self.meals) {
        NSString *summary = [meal hoursSummary];
        if (summary) {
            [summaries addObject:summary];
        }
    }
    return [summaries componentsJoinedByString:@", "];
}

- (DiningMeal *)mealWithName:(NSString *)name
{
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"name == %@", name];
    return [[[self.meals set] filteredSetUsingPredicate:predicate] anyObject];
}

- (DiningMeal *)mealForDate:(NSDate *)date {
    NSPredicate *predicate = [NSPredicate predicateWithFormat:@"startTime <= %@ AND endTime >= %@", date, date];
    
    return [[[self.meals set] filteredSetUsingPredicate:predicate] anyObject];
}

- (DiningMeal *)bestMealForDate:(NSDate *)date {
    
    // get current meal if one is occurring now
    DiningMeal *meal = [self mealForDate:date];
    
    if (!meal) {
        // get next meal to begin
        NSPredicate *predicate = [NSPredicate predicateWithFormat:@"startTime >= %@", date];
        // array keeps order intact, could also use sortdescriptor
        NSArray *meals = [[self.meals array] filteredArrayUsingPredicate:predicate];
        if ([meals count]) {
            meal = meals[0];
        }
    }
    
    if (!meal) {
        // get last meal of the day
        meal = [self.meals lastObject];
    }
    
    return meal;
}


@end
